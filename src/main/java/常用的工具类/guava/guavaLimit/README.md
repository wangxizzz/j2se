# guava限流工具RateLimiter
- RateLimiter和java并发工具Semaphore不同的是，RateLimiter约束的是一段时间内的最大访问次数(通常是1秒钟)，Semaphore约束的是某一时刻的并发个数，强调的是一个时间点，不是一段时间。
- RateLimter自身是一个抽象类，抽象类SmoothRateLimiter继承RateLimter，最终使用的实现类有两个SmoothBursty和SmoothWarmingUp，SmoothBursty使用的是令牌通算法，SmoothWarmingUp使用的是桶漏算法
- 漏桶算法的原理比较简单，请求进入到漏桶中，漏桶以一定的速率漏水。当请求过多时，水直接溢出。所以SmoothWarmingUp可以保证qps一定小于等于自己的设定值。
- 令牌桶算法的原理是系统以一定速率向桶中放入令牌，如果有请求时，请求会从桶中取出令牌，如果能取到令牌，则可以继续完成请求。SmoothBursty的具体规则是：
    - 每秒会有r个令牌放入桶中，或者说，每过1/r秒桶中增加一个令牌，r大于等于0，可以为小数
    - 桶中最多存放r个令牌，如果桶满了，新放入的令牌会被丢弃
    - 虽然SmoothBursty使用的是令牌桶算法，但不是真的维护一个桶，每隔一段时间放入令牌，而是根据令牌桶的算法建立了数学模型来实现功能
- RateLimiter中的SmoothBursty 有一个有趣的特性是「前人挖坑后人跳」，也就是说 RateLimiter 允许某次请求拿走超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上，并且桶中有足够本次请求使用的令牌为止。这里面就涉及到一个权衡，是让前一次请求干等到令牌够用才走掉呢，还是让它先走掉后面的请求等一等呢？Guava 的设计者选择的是后者，先把眼前的活干了，后面的事后面再说。
- Bursty有两个特点： 
    - 提前预支令牌。我们设置了 1k 每秒，而我们可以一次性获取 5k 的 permits，可以预先占有了接下来几秒产生的 permits。
    - 应对突发请求。RateLimiter 会缓存一定数量的 permits 在池中，这样对于突发请求，能及时得到满足。想象一下我们的某个接口，很久没有请求过来，突然同时来了好几个请求，如果我们没有缓存一些 permits 的话，很多线程就需要等待了。


# 总结
RateLimiter只能用于单机的限流，如果想要集群限流，则需要引入 redis或者阿里开源的 sentinel中间件